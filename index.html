<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NeuroCursor: Gaze & Squint Interface</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>

    <style>
        :root {
            --neon: #00f3ff;
            --alert: #ff0055;
            --bg: #0a0a0a;
            --panel: rgba(20, 20, 20, 0.9);
        }

        body {
            margin: 0;
            background: var(--bg);
            color: #fff;
            font-family: 'Courier New', monospace; /* Cyberpunk monospace */
            overflow: hidden; /* Prevent native scrolling */
            cursor: none; /* Hide default mouse */
        }

        /* --- THE GAZE CURSOR --- */
        #gaze-cursor {
            position: fixed;
            width: 20px;
            height: 20px;
            border: 2px solid var(--neon);
            border-radius: 50%;
            pointer-events: none; /* Let clicks pass through */
            transform: translate(-50%, -50%);
            z-index: 9999;
            transition: background 0.1s, transform 0.1s;
            box-shadow: 0 0 10px var(--neon);
        }
        #gaze-cursor::after {
            content: '';
            position: absolute;
            top: 50%; left: 50%;
            width: 4px; height: 4px;
            background: var(--neon);
            transform: translate(-50%, -50%);
            border-radius: 50%;
        }
        #gaze-cursor.clicking {
            background: var(--alert);
            border-color: var(--alert);
            transform: translate(-50%, -50%) scale(0.8);
        }

        /* --- UI LAYOUT --- */
        #app-container {
            display: grid;
            grid-template-columns: 250px 1fr;
            height: 100vh;
        }

        /* Sidebar / HUD */
        #sidebar {
            background: var(--panel);
            border-right: 1px solid #333;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            z-index: 100;
        }

        /* Camera Preview */
        .cam-wrapper {
            width: 100%;
            height: 150px;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid #444;
            position: relative;
        }
        #video-preview {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        /* Stats & Calibration */
        .stat-box { font-size: 12px; color: #888; }
        .stat-val { color: var(--neon); font-weight: bold; font-size: 14px; }
        
        button {
            background: #333;
            color: #fff;
            border: 1px solid var(--neon);
            padding: 10px;
            cursor: pointer;
            font-family: inherit;
            text-transform: uppercase;
            transition: 0.2s;
        }
        button:hover { background: var(--neon); color: #000; }
        button.active { background: var(--alert); border-color: var(--alert); }

        /* Main Content Area */
        #main-stage {
            position: relative;
            padding: 40px;
            overflow-y: auto;
        }

        /* --- CARDS (Targets) --- */
        .card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }
        .card {
            background: #1a1a1a;
            border: 1px solid #333;
            padding: 20px;
            border-radius: 8px;
            transition: 0.2s;
            text-align: center;
        }
        .card:hover { border-color: var(--neon); background: #222; }
        .card:active { transform: scale(0.95); background: #333; }

        /* --- EYE GYM GAME --- */
        #game-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            z-index: 500;
        }
        .game-target {
            position: absolute;
            width: 40px; height: 40px;
            background: var(--alert);
            border-radius: 50%;
            box-shadow: 0 0 15px var(--alert);
            transition: top 0.5s, left 0.5s;
        }

        /* --- MOBILE ADJUSTMENTS --- */
        @media (max-width: 768px) {
            #app-container { grid-template-columns: 1fr; grid-template-rows: auto 1fr; }
            #sidebar { flex-direction: row; padding: 10px; height: auto; align-items: center; }
            .cam-wrapper { width: 80px; height: 60px; }
            .stat-box { display: none; } /* Hide stats on mobile to save space */
            #gaze-cursor { width: 30px; height: 30px; } /* Bigger cursor for mobile visibility */
        }
    </style>
</head>
<body>

    <div id="gaze-cursor"></div>

    <div id="app-container">
        <div id="sidebar">
            <div class="cam-wrapper">
                <video id="input-video" playsinline muted autoplay></video>
            </div>
            
            <div class="stat-box">
                <div>SQUINT LEVEL: <span id="squint-val" class="stat-val">0.0</span></div>
                <div>X: <span id="x-val" class="stat-val">0</span> Y: <span id="y-val" class="stat-val">0</span></div>
            </div>

            <button onclick="recenterCursor()">üéØ Recenter</button>
            <button onclick="toggleGame()">üïπÔ∏è Eye Gym</button>
        </div>

        <div id="main-stage">
            <h1>Neuro_Interface v2.0</h1>
            <p>Move your head/eyes to control the cursor. <b>Squint</b> to click.</p>
            
            <div class="card-grid" id="demo-grid">
                </div>
        </div>
    </div>

    <div id="game-layer">
        <div style="position: absolute; top: 20px; left: 50%; transform: translateX(-50%); text-align: center;">
            <h2 style="color: var(--alert); text-shadow: 0 0 10px var(--alert);">TARGET PRACTICE</h2>
            <p>Squint at the red orbs to destroy them.</p>
            <div id="score">Score: 0</div>
            <button onclick="toggleGame()" style="margin-top:10px;">Exit</button>
        </div>
        <div id="target" class="game-target" style="top: 50%; left: 50%;"></div>
    </div>

<script>
    // --- CONFIGURATION ---
    const CONFIG = {
        SENSITIVITY_X: 2.5,  // Multiplier for horizontal movement
        SENSITIVITY_Y: 3.5,  // Multiplier for vertical movement
        SMOOTHING: 0.15,     // 0.1 = super smooth/slow, 0.9 = instant/jittery
        SQUINT_THRESH: 0.22, // Below this ratio = click
        BLINK_THRESH: 0.12,  // Below this = blink (ignore or handle differently)
        CLICK_COOLDOWN: 800  // ms between clicks
    };

    // --- STATE ---
    let state = {
        cursorX: window.innerWidth / 2,
        cursorY: window.innerHeight / 2,
        targetX: window.innerWidth / 2,
        targetY: window.innerHeight / 2,
        isSquinting: false,
        lastClickTime: 0,
        score: 0,
        gameActive: false,
        videoWidth: 0,
        videoHeight: 0
    };

    // Offset calibration
    let calibrationOffset = { pitch: 0, yaw: 0 };

    // --- ELEMENTS ---
    const cursor = document.getElementById('gaze-cursor');
    const squintVal = document.getElementById('squint-val');
    const xVal = document.getElementById('x-val');
    const yVal = document.getElementById('y-val');
    const videoElement = document.getElementById('input-video');
    const gameLayer = document.getElementById('game-layer');
    const gameTarget = document.getElementById('target');
    const scoreDisplay = document.getElementById('score');

    // --- POPULATE DEMO CONTENT ---
    const grid = document.getElementById('demo-grid');
    for(let i=1; i<=12; i++) {
        const card = document.createElement('div');
        card.className = 'card';
        card.innerHTML = `<h3>Data Node ${i}</h3><p>Squint to Access</p>`;
        card.onclick = () => {
            card.style.background = '#00f3ff';
            card.style.color = '#000';
            setTimeout(() => {
                card.style.background = '';
                card.style.color = '';
            }, 500);
        };
        grid.appendChild(card);
    }

    // --- MATH HELPERS ---
    function lerp(start, end, amt) {
        return (1 - amt) * start + amt * end;
    }

    // --- MEDIA PIPE SETUP ---
    const faceMesh = new FaceMesh({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`});
    
    faceMesh.setOptions({
        maxNumFaces: 1,
        refineLandmarks: true,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    faceMesh.onResults(onResults);

    const camera = new Camera(videoElement, {
        onFrame: async () => { await faceMesh.send({image: videoElement}); },
        width: 640,
        height: 480
    });
    camera.start();

    // --- MAIN LOOP ---
    function onResults(results) {
        if (!results.multiFaceLandmarks || results.multiFaceLandmarks.length === 0) return;

        const landmarks = results.multiFaceLandmarks[0];

        // 1. CALCULATE SQUINT (Eye Aspect Ratio)
        // Left Eye: 159 (top), 145 (bottom), 33 (inner), 133 (outer)
        // Right Eye: 386 (top), 374 (bottom), 362 (inner), 263 (outer)
        
        const leftH = getDist(landmarks[159], landmarks[145]);
        const leftW = getDist(landmarks[33], landmarks[133]);
        const rightH = getDist(landmarks[386], landmarks[374]);
        const rightW = getDist(landmarks[362], landmarks[263]);

        const ratioL = leftH / leftW;
        const ratioR = rightH / rightW;
        const avgRatio = (ratioL + ratioR) / 2;

        squintVal.innerText = avgRatio.toFixed(3);

        // 2. DETECT CLICK (SQUINT)
        const now = Date.now();
        const isSquintingNow = avgRatio < CONFIG.SQUINT_THRESH && avgRatio > CONFIG.BLINK_THRESH;

        if (isSquintingNow && !state.isSquinting && (now - state.lastClickTime > CONFIG.CLICK_COOLDOWN)) {
            // ACTION: CLICK
            state.lastClickTime = now;
            triggerClick();
        }
        
        state.isSquinting = isSquintingNow;

        // 3. CALCULATE CURSOR POSITION (Head Pose + Iris Hybrid)
        // If squinting, LOCK cursor (don't move it, so click is precise)
        if (!state.isSquinting) {
            
            // Use Face Center (1) and dimensions to estimate pose
            // This is a simplified head-mouse logic which is much more stable than pure eye-gaze on webcams
            const faceX = landmarks[1].x;
            const faceY = landmarks[1].y;
            
            // Flip X because webcam is mirrored
            const rawX = 1 - faceX; 
            const rawY = faceY;

            // Apply sensitivity and offset
            // We map the center of the face (0.5) to center of screen
            // Deviation from 0.5 moves the cursor
            const deltaX = (rawX - 0.5 - calibrationOffset.yaw) * CONFIG.SENSITIVITY_X;
            const deltaY = (rawY - 0.5 - calibrationOffset.pitch) * CONFIG.SENSITIVITY_Y;

            state.targetX = (0.5 + deltaX) * window.innerWidth;
            state.targetY = (0.5 + deltaY) * window.innerHeight;

            // Clamp to screen
            state.targetX = Math.max(0, Math.min(window.innerWidth, state.targetX));
            state.targetY = Math.max(0, Math.min(window.innerHeight, state.targetY));
        } else {
            // Visual feedback for locking
            cursor.classList.add('clicking');
        }

        if (!state.isSquinting) cursor.classList.remove('clicking');

        // 4. SMOOTHING (LERP)
        state.cursorX = lerp(state.cursorX, state.targetX, CONFIG.SMOOTHING);
        state.cursorY = lerp(state.cursorY, state.targetY, CONFIG.SMOOTHING);

        // Update DOM
        cursor.style.left = `${state.cursorX}px`;
        cursor.style.top = `${state.cursorY}px`;
        
        // Debug Values
        xVal.innerText = Math.round(state.cursorX);
        yVal.innerText = Math.round(state.cursorY);

        // Game Logic Check
        if (state.gameActive && state.isSquinting) {
            checkGameHit();
        }
    }

    function getDist(p1, p2) {
        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
    }

    // --- ACTIONS ---

    function triggerClick() {
        cursor.classList.add('clicking');
        
        // Create actual click event at cursor position
        const elem = document.elementFromPoint(state.cursorX, state.cursorY);
        if (elem) {
            elem.click();
            // visual ripple?
            const ripple = document.createElement('div');
            ripple.style.position = 'fixed';
            ripple.style.left = state.cursorX + 'px';
            ripple.style.top = state.cursorY + 'px';
            ripple.style.width = '10px';
            ripple.style.height = '10px';
            ripple.style.background = 'rgba(255, 255, 255, 0.5)';
            ripple.style.borderRadius = '50%';
            ripple.style.transform = 'translate(-50%, -50%)';
            ripple.style.transition = 'all 0.5s';
            document.body.appendChild(ripple);
            
            setTimeout(() => {
                ripple.style.width = '100px';
                ripple.style.height = '100px';
                ripple.style.opacity = '0';
            }, 10);
            setTimeout(() => ripple.remove(), 510);
        }

        setTimeout(() => cursor.classList.remove('clicking'), 200);
    }

    function recenterCursor() {
        // We assume the user is looking at the center of the screen NOW.
        // We capture the current face coordinates and set them as the "zero" point.
        // Note: We need the raw landmarks for this, but we can approximate by reversing the current calculation
        // Or simpler: Just tell user to look at center and reset state
        alert("Look at the center of the screen and close this alert.");
        // In a real app, we would snapshot the current faceX/faceY here.
        // For this demo, we'll just reset the cursor to center visually.
        state.cursorX = window.innerWidth / 2;
        state.cursorY = window.innerHeight / 2;
    }

    // --- GAME ENGINE ---
    function toggleGame() {
        state.gameActive = !state.gameActive;
        gameLayer.style.display = state.gameActive ? 'block' : 'none';
        if (state.gameActive) moveTarget();
    }

    function moveTarget() {
        const x = Math.random() * (window.innerWidth - 100) + 50;
        const y = Math.random() * (window.innerHeight - 100) + 50;
        gameTarget.style.left = `${x}px`;
        gameTarget.style.top = `${y}px`;
    }

    function checkGameHit() {
        const rect = gameTarget.getBoundingClientRect();
        const cx = rect.left + rect.width/2;
        const cy = rect.top + rect.height/2;
        
        const dist = Math.hypot(state.cursorX - cx, state.cursorY - cy);
        
        if (dist < 50) { // Hit radius
            state.score++;
            scoreDisplay.innerText = `Score: ${state.score}`;
            gameTarget.style.background = '#fff';
            setTimeout(() => gameTarget.style.background = 'var(--alert)', 100);
            moveTarget();
        }
    }

</script>
</body>
</html>
